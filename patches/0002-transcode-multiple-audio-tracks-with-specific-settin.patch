From 09628a0383894bdf7c84bfd8df6a777a2c75b795 Mon Sep 17 00:00:00 2001
From: =?utf-8?q?Rafa=C3=ABl=20Carr=C3=A9?= <rafael.carre@gmail.com>
Date: Mon, 7 Dec 2009 04:40:41 +0100
Subject: [PATCH 2/7] transcode multiple audio tracks with specific settings each

---
 modules/stream_out/transcode/audio.c     |   30 +++--
 modules/stream_out/transcode/transcode.c |  215 ++++++++++++++++++++++++------
 modules/stream_out/transcode/transcode.h |   20 ++-
 3 files changed, 202 insertions(+), 63 deletions(-)

diff --git a/modules/stream_out/transcode/audio.c b/modules/stream_out/transcode/audio.c
index 5895b6f..4352da7 100644
--- a/modules/stream_out/transcode/audio.c
+++ b/modules/stream_out/transcode/audio.c
@@ -208,6 +208,7 @@ int transcode_audio_new( sout_stream_t *p_stream,
 {
     sout_stream_sys_t *p_sys = p_stream->p_sys;
     es_format_t fmt_last;
+    unsigned i_track = id->i_audio;
 
     /*
      * Open decoder
@@ -257,14 +258,14 @@ int transcode_audio_new( sout_stream_t *p_stream,
     id->p_encoder->fmt_in.audio.i_bitspersample =
         aout_BitsPerSample( id->p_encoder->fmt_in.i_codec );
 
-    id->p_encoder->p_cfg = p_stream->p_sys->p_audio_cfg;
-    id->p_encoder->p_module =
-        module_need( id->p_encoder, "encoder", p_sys->psz_aenc, true );
+    id->p_encoder->p_cfg = p_stream->p_sys->pp_audio_cfg[i_track];
+    id->p_encoder->p_module = module_need( id->p_encoder, "encoder",
+            p_sys->ppsz_aenc[i_track], true );
     if( !id->p_encoder->p_module )
     {
         msg_Err( p_stream, "cannot find audio encoder (module:%s fourcc:%4.4s)",
-                 p_sys->psz_aenc ? p_sys->psz_aenc : "any",
-                 (char *)&p_sys->i_acodec );
+                 p_sys->ppsz_aenc[i_track] ? p_sys->ppsz_aenc[i_track] : "any",
+                 (char *)&p_sys->i_acodec[i_track] );
         module_unneed( id->p_decoder, id->p_decoder->p_module );
         id->p_decoder->p_module = NULL;
         return VLC_EGENERIC;
@@ -274,7 +275,7 @@ int transcode_audio_new( sout_stream_t *p_stream,
         aout_BitsPerSample( id->p_encoder->fmt_in.i_codec );
 
     /* Load user specified audio filters */
-    if( p_sys->psz_af )
+    if( p_sys->ppsz_af[i_track] )
     {
         es_format_t fmt_fl32 = fmt_last;
         fmt_fl32.i_codec =
@@ -290,7 +291,7 @@ int transcode_audio_new( sout_stream_t *p_stream,
         id->p_uf_chain = filter_chain_New( p_stream, "audio filter", false,
                                            transcode_audio_filter_allocation_init, NULL, NULL );
         filter_chain_Reset( id->p_uf_chain, &fmt_last, &fmt_fl32 );
-        if( filter_chain_AppendFromString( id->p_uf_chain, p_sys->psz_af ) > 0 )
+        if( filter_chain_AppendFromString( id->p_uf_chain, p_sys->ppsz_af[i_track] ) > 0 )
             fmt_last = *filter_chain_GetFmtOut( id->p_uf_chain );
     }
 
@@ -398,20 +399,21 @@ bool transcode_audio_add( sout_stream_t *p_stream, es_format_t *p_fmt,
             sout_stream_id_t *id )
 {
     sout_stream_sys_t *p_sys = p_stream->p_sys;
+    unsigned i_track = id->i_audio;
 
     msg_Dbg( p_stream,
              "creating audio transcoding from fcc=`%4.4s' to fcc=`%4.4s'",
-             (char*)&p_fmt->i_codec, (char*)&p_sys->i_acodec );
+             (char*)&p_fmt->i_codec, (char*)&p_sys->i_acodec[i_track] );
 
     /* Complete destination format */
-    id->p_encoder->fmt_out.i_codec = p_sys->i_acodec;
-    id->p_encoder->fmt_out.audio.i_rate = p_sys->i_sample_rate > 0 ?
-        p_sys->i_sample_rate : p_fmt->audio.i_rate;
-    id->p_encoder->fmt_out.i_bitrate = p_sys->i_abitrate;
+    id->p_encoder->fmt_out.i_codec = p_sys->i_acodec[i_track];
+    id->p_encoder->fmt_out.audio.i_rate = p_sys->i_sample_rate[i_track] > 0 ?
+        p_sys->i_sample_rate[i_track] : p_fmt->audio.i_rate;
+    id->p_encoder->fmt_out.i_bitrate = p_sys->i_abitrate[i_track];
     id->p_encoder->fmt_out.audio.i_bitspersample =
         p_fmt->audio.i_bitspersample;
-    id->p_encoder->fmt_out.audio.i_channels = p_sys->i_channels > 0 ?
-        p_sys->i_channels : p_fmt->audio.i_channels;
+    id->p_encoder->fmt_out.audio.i_channels = p_sys->i_channels[i_track] > 0 ?
+        p_sys->i_channels[i_track] : p_fmt->audio.i_channels;
     /* Sanity check for audio channels */
     id->p_encoder->fmt_out.audio.i_channels =
         __MIN( id->p_encoder->fmt_out.audio.i_channels,
diff --git a/modules/stream_out/transcode/transcode.c b/modules/stream_out/transcode/transcode.c
index 2227f8b..c19281f 100644
--- a/modules/stream_out/transcode/transcode.c
+++ b/modules/stream_out/transcode/transcode.c
@@ -190,23 +190,23 @@ vlc_module_begin ()
                      VFILTER_TEXT, VFILTER_LONGTEXT, false )
 
     set_section( N_("Audio"), NULL )
-    add_module( SOUT_CFG_PREFIX "aenc", "encoder", NULL, NULL, AENC_TEXT,
-                AENC_LONGTEXT, false )
+    /*add_module( SOUT_CFG_PREFIX "aenc", "encoder", NULL, NULL, AENC_TEXT,
+                AENC_LONGTEXT, false )*/
     add_string( SOUT_CFG_PREFIX "acodec", NULL, NULL, ACODEC_TEXT,
                 ACODEC_LONGTEXT, false )
-    add_integer( SOUT_CFG_PREFIX "ab", 0, NULL, AB_TEXT,
+    add_string( SOUT_CFG_PREFIX "ab", 0, NULL, AB_TEXT,
                  AB_LONGTEXT, false )
     add_string( SOUT_CFG_PREFIX "alang", NULL, NULL, ALANG_TEXT,
                 ALANG_LONGTEXT, true )
-    add_integer( SOUT_CFG_PREFIX "channels", 0, NULL, ACHANS_TEXT,
+    add_string( SOUT_CFG_PREFIX "channels", 0, NULL, ACHANS_TEXT,
                  ACHANS_LONGTEXT, false )
-    add_integer( SOUT_CFG_PREFIX "samplerate", 0, NULL, ARATE_TEXT,
+    add_string( SOUT_CFG_PREFIX "samplerate", 0, NULL, ARATE_TEXT,
                  ARATE_LONGTEXT, true )
     add_bool( SOUT_CFG_PREFIX "audio-sync", false, NULL, ASYNC_TEXT,
               ASYNC_LONGTEXT, false )
-    add_module_list( SOUT_CFG_PREFIX "afilter",  "audio filter",
+    /*add_module_list( SOUT_CFG_PREFIX "afilter",  "audio filter",
                      NULL, NULL,
-                     AFILTER_TEXT, AFILTER_LONGTEXT, false )
+                     AFILTER_TEXT, AFILTER_LONGTEXT, false )*/
 
     set_section( N_("Overlays/Subtitles"), NULL )
     add_module( SOUT_CFG_PREFIX "senc", "encoder", NULL, NULL, SENC_TEXT,
@@ -272,9 +272,80 @@ static int Open( vlc_object_t *p_this )
                    p_stream->p_cfg );
 
     /* Audio transcoding parameters */
+    p_sys->i_acodec = NULL;
+    p_sys->i_audio_tracks = 0;
+    p_sys->i_audio_current = 0;
+    var_Get( p_stream, SOUT_CFG_PREFIX "acodec", &val );
+    if( val.psz_string && *val.psz_string )
+    {
+        char *psz_parser = val.psz_string;
+        p_sys->i_acodec = NULL;
+        while(*psz_parser)
+        {
+            vlc_fourcc_t *p_acodec = realloc(p_sys->i_acodec,
+                (p_sys->i_audio_tracks+1) * sizeof(vlc_fourcc_t));
+            if(!p_acodec)
+            {
+                free(p_sys->i_acodec);
+                free(val.psz_string);
+                return VLC_ENOMEM;
+            }
+            p_sys->i_acodec = p_acodec;
+
+            size_t len = strcspn(psz_parser, ",");
+            if(len)
+            {
+                char fcc[4] = "    ";
+                memcpy(fcc, val.psz_string, __MIN(len, 4));
+                if(!strncmp(fcc, "copy", 4))
+                    p_sys->i_acodec[p_sys->i_audio_tracks++] = 0; /* copy */
+                else
+                    p_sys->i_acodec[p_sys->i_audio_tracks++] =
+                        VLC_FOURCC( fcc[0], fcc[1], fcc[2], fcc[3] );
+            }
+            else
+                p_sys->i_acodec[p_sys->i_audio_tracks++] = 0; /* copy */
+            psz_parser += len + 1;
+        }
+    }
+    free( val.psz_string );
+
+    p_sys->pp_audio_cfg = malloc(sizeof(config_chain_t*) * p_sys->i_audio_tracks);
+    p_sys->ppsz_aenc = malloc(sizeof(char*) * p_sys->i_audio_tracks);
+    p_sys->ppsz_af = malloc(sizeof(char*) * p_sys->i_audio_tracks);
+    p_sys->ppsz_alang = malloc(sizeof(char*) * p_sys->i_audio_tracks);
+    p_sys->i_sample_rate = malloc(sizeof(uint32_t) * p_sys->i_audio_tracks);
+    p_sys->i_channels = malloc(sizeof(uint32_t) * p_sys->i_audio_tracks);
+    p_sys->i_abitrate = malloc(sizeof(int) * p_sys->i_audio_tracks);
+    if( !p_sys->pp_audio_cfg || !p_sys->ppsz_aenc || !p_sys->ppsz_af ||
+        !p_sys->ppsz_alang || !p_sys->i_sample_rate || !p_sys->i_channels ||
+        !p_sys->i_abitrate )
+    {
+        free(p_sys->pp_audio_cfg);
+        free(p_sys->ppsz_aenc);
+        free(p_sys->ppsz_af);
+        free(p_sys->ppsz_alang);
+        free(p_sys->i_sample_rate);
+        free(p_sys->i_channels);
+        free(p_sys->i_abitrate);
+        free(p_sys->i_acodec);
+
+        return VLC_ENOMEM;
+    }
+
+    for(unsigned i = 0; i < p_sys->i_audio_tracks; i++)
+    {
+        p_sys->pp_audio_cfg[i] = NULL;
+        p_sys->ppsz_aenc[i] = NULL;
+        p_sys->ppsz_af[i] = NULL;
+        p_sys->ppsz_alang[i] = NULL;
+        p_sys->i_sample_rate[i] = 0;
+        p_sys->i_channels[i] = 0;
+        p_sys->i_abitrate[i] = 0;
+    }
+
+#if 0 /* FIXME : syntax */
     var_Get( p_stream, SOUT_CFG_PREFIX "aenc", &val );
-    p_sys->psz_aenc = NULL;
-    p_sys->p_audio_cfg = NULL;
     if( val.psz_string && *val.psz_string )
     {
         char *psz_next;
@@ -283,43 +354,88 @@ static int Open( vlc_object_t *p_this )
         free( psz_next );
     }
     free( val.psz_string );
-
-    var_Get( p_stream, SOUT_CFG_PREFIX "acodec", &val );
-    p_sys->i_acodec = 0;
-    if( val.psz_string && *val.psz_string )
+#endif
+    char *psz_alang = var_GetNonEmptyString( p_stream, SOUT_CFG_PREFIX "alang" );
+    if(psz_alang)
     {
-        char fcc[4] = "    ";
-        memcpy( fcc, val.psz_string, __MIN( strlen( val.psz_string ), 4 ) );
-        p_sys->i_acodec = VLC_FOURCC( fcc[0], fcc[1], fcc[2], fcc[3] );
+        unsigned i = 0;
+        char *psz_parser = psz_alang;
+        while(i < p_sys->i_audio_tracks && *psz_parser)
+        {
+            size_t len = strcspn(psz_parser, ",");
+            p_sys->ppsz_alang[i++] = strndup(psz_parser, len);
+            psz_parser += len + 1;
+        }
+        free(psz_alang);
     }
-    free( val.psz_string );
-
-    p_sys->psz_alang = var_GetNonEmptyString( p_stream, SOUT_CFG_PREFIX "alang" );
 
-    var_Get( p_stream, SOUT_CFG_PREFIX "ab", &val );
-    p_sys->i_abitrate = val.i_int;
-    if( p_sys->i_abitrate < 4000 ) p_sys->i_abitrate *= 1000;
+    char *psz_ab = var_GetNonEmptyString( p_stream, SOUT_CFG_PREFIX "ab" );
+    if(psz_ab)
+    {
+        unsigned i = 0;
+        char *psz_parser = psz_ab;
+        while(i < p_sys->i_audio_tracks && *psz_parser)
+        {
+            size_t len = strcspn(psz_parser, ",");
+            psz_parser[len] = '\0';
+            int ab = atoi(psz_parser);
+            if( ab < 4000 ) ab *= 1000;
+            p_sys->i_abitrate[i++] = ab;
+            psz_parser += len + 1;
+        }
+        free(psz_ab);
+    }
 
-    var_Get( p_stream, SOUT_CFG_PREFIX "samplerate", &val );
-    p_sys->i_sample_rate = val.i_int;
+    char *psz_samplerate = var_GetNonEmptyString( p_stream, SOUT_CFG_PREFIX "samplerate" );
+    if(psz_samplerate)
+    {
+        unsigned i = 0;
+        char *psz_parser = psz_samplerate;
+        while(i < p_sys->i_audio_tracks && *psz_parser)
+        {
+            size_t len = strcspn(psz_parser, ",");
+            psz_parser[len] = '\0';
+            p_sys->i_sample_rate[i++] = atoi(psz_parser);
+            psz_parser += len + 1;
+        }
+        free(psz_samplerate);
+    }
 
-    var_Get( p_stream, SOUT_CFG_PREFIX "channels", &val );
-    p_sys->i_channels = val.i_int;
+    char *psz_channels = var_GetNonEmptyString( p_stream, SOUT_CFG_PREFIX "channels" );
+    if(psz_channels)
+    {
+        unsigned i = 0;
+        char *psz_parser = psz_channels;
+        while(i < p_sys->i_audio_tracks && *psz_parser)
+        {
+            size_t len = strcspn(psz_parser, ",");
+            psz_parser[len] = '\0';
+            p_sys->i_channels[i++] = atoi(psz_parser);
+            psz_parser += len + 1;
+        }
+        free(psz_channels);
+    }
 
     if( p_sys->i_acodec )
     {
-        if( ( p_sys->i_acodec == VLC_CODEC_MP3 ||
-              p_sys->i_acodec == VLC_CODEC_MPGA ) && p_sys->i_channels > 2 )
+        msg_Dbg( p_stream, "%d audio tracks", p_sys->i_audio_tracks );
+
+        for(unsigned i = 0; i < p_sys->i_audio_tracks; i++)
         {
-            msg_Warn( p_stream, "%d channels invalid for mp3, forcing to 2",
-                      p_sys->i_channels );
-            p_sys->i_channels = 2;
+            if( ( p_sys->i_acodec[i] == VLC_CODEC_MP3 ||
+                  p_sys->i_acodec[i] == VLC_CODEC_MPGA ) && p_sys->i_channels[i] > 2 )
+            {
+                msg_Warn( p_stream, "%d channels invalid for mp3, forcing to 2",
+                          p_sys->i_channels[i] );
+                p_sys->i_channels[i] = 2;
+            }
+            msg_Dbg( p_stream, "codec audio=%4.4s %dHz %d channels %dKb/s",
+                     (char *)&p_sys->i_acodec[i], p_sys->i_sample_rate[i],
+                     p_sys->i_channels[i], p_sys->i_abitrate[i] / 1000 );
         }
-        msg_Dbg( p_stream, "codec audio=%4.4s %dHz %d channels %dKb/s",
-                 (char *)&p_sys->i_acodec, p_sys->i_sample_rate,
-                 p_sys->i_channels, p_sys->i_abitrate / 1000 );
     }
 
+#if 0 /* FIXME : syntax */
     var_Get( p_stream, SOUT_CFG_PREFIX "afilter", &val );
     if( val.psz_string && *val.psz_string )
         p_sys->psz_af = val.psz_string;
@@ -328,6 +444,7 @@ static int Open( vlc_object_t *p_this )
         free( val.psz_string );
         p_sys->psz_af = NULL;
     }
+#endif
 
     /* Video transcoding parameters */
     var_Get( p_stream, SOUT_CFG_PREFIX "venc", &val );
@@ -517,11 +634,20 @@ static void Close( vlc_object_t * p_this )
 
     sout_StreamDelete( p_sys->p_out );
 
-    free( p_sys->psz_af );
+    for(unsigned i = 0; i < p_sys->i_audio_tracks; i++)
+    {
+        config_ChainDestroy( p_sys->pp_audio_cfg[i] );
+        free( p_sys->ppsz_alang[i] );
+    }
+    free( p_sys->ppsz_af );
+    free( p_sys->ppsz_aenc );
+    free(p_sys->i_acodec);
+    free(p_sys->ppsz_alang);
+    free(p_sys->pp_audio_cfg);
+    free(p_sys->i_sample_rate);
+    free(p_sys->i_abitrate);
+    free(p_sys->i_channels);
 
-    config_ChainDestroy( p_sys->p_audio_cfg );
-    free( p_sys->psz_aenc );
-    free( p_sys->psz_alang );
 
     free( p_sys->psz_vf2 );
 
@@ -576,14 +702,21 @@ static sout_stream_id_t *Add( sout_stream_t *p_stream, es_format_t *p_fmt )
     id->p_encoder->fmt_out.i_id    = p_fmt->i_id;
     id->p_encoder->fmt_out.i_group = p_fmt->i_group;
 
-    if( p_sys->psz_alang )
-        id->p_encoder->fmt_out.psz_language = strdup( p_sys->psz_alang );
+    if( p_fmt->i_cat == AUDIO_ES && p_sys->ppsz_alang &&
+        p_sys->i_audio_tracks && p_sys->ppsz_alang[p_sys->i_audio_current] )
+    {
+        id->p_encoder->fmt_out.psz_language =
+            strdup( p_sys->ppsz_alang[p_sys->i_audio_current] );
+    }
     else if( p_fmt->psz_language )
         id->p_encoder->fmt_out.psz_language = strdup( p_fmt->psz_language );
 
     bool success;
 
-    if( p_fmt->i_cat == AUDIO_ES && (p_sys->i_acodec || p_sys->psz_aenc) )
+    if( p_fmt->i_cat == AUDIO_ES && p_sys->i_audio_tracks )
+        id->i_audio = p_sys->i_audio_current++;
+
+    if( p_fmt->i_cat == AUDIO_ES && p_sys->i_audio_tracks && (p_sys->i_acodec[id->i_audio] || p_sys->ppsz_aenc[id->i_audio]) )
         success = transcode_audio_add(p_stream, p_fmt, id);
     else if( p_fmt->i_cat == VIDEO_ES && (p_sys->i_vcodec || p_sys->psz_venc) )
         success = transcode_video_add(p_stream, p_fmt, id);
diff --git a/modules/stream_out/transcode/transcode.h b/modules/stream_out/transcode/transcode.h
index dd7b3bf..1508ce0 100644
--- a/modules/stream_out/transcode/transcode.h
+++ b/modules/stream_out/transcode/transcode.h
@@ -28,15 +28,18 @@ struct sout_stream_sys_t
     int             i_first_pic, i_last_pic;
 
     /* Audio */
-    vlc_fourcc_t    i_acodec;   /* codec audio (0 if not transcode) */
-    char            *psz_aenc;
-    char            *psz_alang;
-    config_chain_t  *p_audio_cfg;
-    uint32_t        i_sample_rate;
-    uint32_t        i_channels;
-    int             i_abitrate;
+    unsigned        i_audio_tracks;
+    unsigned        i_audio_current;
 
-    char            *psz_af;
+    vlc_fourcc_t    *i_acodec;   /* codec audio (0 if not transcode) */
+    char            **ppsz_aenc;
+    char            **ppsz_alang;
+    config_chain_t  **pp_audio_cfg;
+    uint32_t        *i_sample_rate;
+    uint32_t        *i_channels;
+    int             *i_abitrate;
+
+    char            **ppsz_af;
 
     /* Video */
     vlc_fourcc_t    i_vcodec;   /* codec video (0 if not transcode) */
@@ -77,6 +80,7 @@ struct sout_stream_sys_t
 struct sout_stream_id_t
 {
     bool            b_transcode;
+    unsigned        i_audio;
 
     /* id of the out stream */
     void *id;
-- 
1.6.3.3

